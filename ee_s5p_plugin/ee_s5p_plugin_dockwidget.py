# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EarthEngineSentinel5PDockWidget
                                 A QGIS plugin
 This plugin ports the Copernicus S5P Near Real Time and Offline L3 datasets found on Google Earth Engine
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-12-06
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Brandon Crosbie
        email                : bcrosb31@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import math
import csv
import json
import geojson
import requests
import time
import datetime

# For Map Interaction
import qgis.core
from qgis.core import *
import qgis.utils
from qgis.utils import *


# qgis plugin builder Default
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal


# For GUI/Widget Creation

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal

# for iface
from qgis.core import QgsRasterLayer
from qgis.core import QgsVectorLayer
from qgis.core import QgsProject
from qgis.core import QgsCoordinateReferenceSystem

from qgis.utils import iface

from qgis.gui import QgsMapCanvas, QgsVertexMarker

# For Datatypes
from PyQt5.QtGui import QStandardItemModel, QStandardItem,  QDoubleValidator, QIntValidator

# For Visual
from PyQt5.QtGui import QColor

# For Pop Up StatusBar Messages/Warnings/file handling 
from PyQt5.QtWidgets import QFileDialog, QDialog, QMessageBox, QWidget, QGridLayout, QLabel, QMenu, QStatusBar, QScrollArea, QVBoxLayout

# For auto Completer
from PyQt5.QtWidgets import QCompleter

# For Results List Buttons
from PyQt5.Qt import Qt

# For Results List
from PyQt5.QtCore import QVariant

# For Time Filter
from PyQt5.QtCore import QDate


# EXTRA REQUIREMENTS
# Requires pip installation for QGIS
from bs4 import BeautifulSoup

# Earth Engine Python Library
import ee


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ee_s5p_plugin_dockwidget_base.ui'))


class EarthEngineSentinel5PDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(EarthEngineSentinel5PDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
    
        #=====================================
        # User added init methods for ee_s5p_plugin
        #=====================================

        # Catalog includes all possible datasets to query
        self.catalog = []
        
        # Results are User selected datasets in List View
        self.results = None

        # Start button initiates the session for class, and loads catalog
        # self.formBeginStartBTN.clicked.connect(self.Start)

        # Reset button will clear all items from last session
        self.formBeginResetBTN.clicked.connect(self.Reset)

        
        # ====== Filter Attributes ====== #
        # Define Tabs for filtering datasets

        # ========= TAB: Type ==========#
        # TYPE: Drop Down for Dataset Type
        self.dataset_types = []
        # Allows reverse lookup on Dataset Type
        self.type_id_lookup = {}

        # Drop Down: Dataset Publisher:
        self.dataset_publishers = []
        # Allows reverse lookup on Publisher
        self.publisher_id_lookup = {}

        # Initialize Combo Box Features: Dataset Type
        self.filterDatasetTypeCB.setDuplicatesEnabled(False)
        self.filterDatasetTypeCB.currentTextChanged.connect(self.change_on_dataset_type)

        # Initialize Combo Box Features: Dataset Publisher
        self.filterDatasetPublisherCB.setDuplicatesEnabled(False)
        self.filterDatasetPublisherCB.currentTextChanged.connect(self.change_on_publisher)

        # ========= TAB: Tags ==========#
        # Running list of tags in filter
        self.tag_list = []
        # Total tag list in all results
        self.all_tags = []
        # Allows reverse lookup on tag
        self.tag_id_lookup = {}

        # Initialize Clear Tag Button
        self.filterTagClearBTN.clicked.connect(self.clearFilterOptions)

        # Initialize Tag AND|OR radio buttons
        self.filterTagOrRB.setChecked(True)
        self.filterTagAndRB.setChecked(False)
        self.filterTagOrRB.toggled.connect(self.tagLogicSwitch)
        self.filterTagAndRB.toggled.connect(self.tagLogicSwitch)

        # Enable press Return for LE to enter Tags
        self.filterTagSelectLE.returnPressed.connect(self.updateTagList)
        
        # ========= TAB: Location ==========#
        # Initialize the Lat/Lon format Line Edit
        # This section is for the user to find a custom or immediate location
        self.locationSearchLatitudeLE.setValidator(QDoubleValidator(-90, -90, 9))
        self.locationSearchLongitudeLE.setValidator(QDoubleValidator(-180, 180, 9))
        self.locationSearchBTN.clicked.connect(self.find_me)
        
        # Allow custom radius around input Latitude/Longitude
        self.locationFilterRadiusLE.setValidator(QDoubleValidator(0, 10000000, 9))
        self.locationFilterUnitKmRB.setChecked(True)
        self.locationFilterUnitMiRB.setChecked(False)
        self.locationFilterUnitKmRB.toggled.connect(self.unitLogicSwitch)
        self.locationFilterUnitMiRB.toggled.connect(self.unitLogicSwitch)

        # Defined for common shapes Hexagon and Rectangle
        self.locationFilterGeometryCB.setDuplicatesEnabled(False)
        self.locationFilterGeometryCB.addItem('Rectangle')
        self.locationFilterGeometryCB.addItem('Hexagon')
        self.locationFilterApplyBTN.clicked.connect(self.generate_polygon_poi)

        # For Interactive Drawing:
        # self.geometrySelectedOnMapBTN.clicked.connect(self.getSelectedGeometry)
        # self.geometryAllOnMapBTN.clicked.connect(self.getAllGeometry)
        # self.geometryClearBTN.clicked.connect(self.clearGeometryFilter)

        self.filter_points = []
        
        # ===== Time Group =====
        # Start
        self.filterTimeStartDE.setDisplayFormat("yyyy-MM-dd")
        self.filterTimeStartDE.setMaximumDate(QDate.currentDate().addDays(-1))
        self.filterTimeStartDE.dateChanged.connect(self.change_start_date)
        # End
        self.filterTimeEndDE.setDisplayFormat("yyyy-MM-dd")
        self.filterTimeEndDE.setMaximumDate(QDate.currentDate())
        self.filterTimeEndDE.setDate(QDate.currentDate())

        # Time Combo Box
        self.filterTimeDefaultCB.setDuplicatesEnabled(False)
        self.filterTimeDefaultCB.addItem('')
        self.filterTimeDefaultCB.addItem('1D')
        self.filterTimeDefaultCB.addItem('7D')
        self.filterTimeDefaultCB.addItem('1M')
        self.filterTimeDefaultCB.addItem('3M')
        self.filterTimeDefaultCB.addItem('6M')
        self.filterTimeDefaultCB.addItem('1Y')
        self.filterTimeDefaultCB.addItem('YTD')
        self.filterTimeDefaultCB.currentTextChanged.connect(self.handle_time)

        # ===== SEARCH ===== 
        # Connect Search Button to update List View of Results
        self.searchAllBTN.clicked.connect(self.Search)

        # ===== Results Group =====
        self.resultsSelectClearAllBTN.clicked.connect(self.clear_results)
        self.resultsGetDetailsBTN.clicked.connect(self.getDetails)

        # Band Selection + Palette + Request Calc
        self.selectResultBTN.clicked.connect(self.select_result)
        
        # ===== Extract Data / Automation Group =====
        self.extractBandSelectCB.setDuplicatesEnabled(False)

        # Set Resolution limits
        self.extractResolutionLE.setValidator(QDoubleValidator(0.15, 100000, 0.0001))

        # Extract Data BTN
        self.extractBTN.clicked.connect(self.Extract)

        # Add Layer Button
        self.applyDefaultPaletteBTN.clicked.connect(self.apply_palette)
        
        # Save extracted layer data in new attribute
        self.extract_data = []
        self.request_metadata = {}

        #=====================================
        # End of User added init methods
        #=====================================
        # Start up Automatically
        self.Start()

    #==============================================================
    # Default class method "closeEvent" from QGIS Plugin Builder
    #==============================================================
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
    #==============================================================

    #==============================================================
    # User Custom class methods: required CRUD across multiple Groups
    #==============================================================
    

    
    #=====================================
    # (script: ee_catalog.py) webscrape using bs4 
    #=====================================
    def init_ee_catalog(self):
        """ Script will automatically import the catalog JSON
            OR if no file exists, run the webscraper to extract metadata"""
        from .scripts import ee_catalog
        catalog = ee_catalog.read_catalog()
        self.catalog = catalog

    
    #=====================================
    # First Check EE Plugin Installed (Already Native to QGIS) 
    #=====================================
    def init_ee_plugin(self):
        """Run this with Start"""
        try:
            import ee
            # from ee_plugin import Map
        except Exception as e:
            QMessageBox.information(self, 'EE PLUGIN MISSING', str(e), QMessageBox.Ok)

        return


    #=====================================
    # Check used for selection iteration for current results
    #=====================================

    def check_results(self):
        """ Results initialized as None
            some functions will need to check catalog 
            i.e. for drop down/list options """

        if self.results is None:
            return self.catalog

        else:
            return self.results


    #=====================================
    # the findAll Series produces reverse lookup dictionaries
    #=====================================
    
    def findAll_DatasetTypes(self):
        """ For all Dataset Types: Image/ImageCollection/FeatureCollection """
        # When changing Dataset Type, we need to refresh from entire catalog
        selection = self.catalog
        
        dataset_types = []
        type_id_lookup = {}
        for dataset in selection:
            d_type = dataset['dataset_type']

            # REORG: Datatype-> datasets
            # This will reorg the dataset types to lookup easily
            if d_type not in dataset_types:
                dataset_types.append(d_type)
                type_id_lookup.update({d_type: [dataset]})

            else:
                type_id_lookup[d_type].append(dataset)

        self.dataset_types = dataset_types
        self.type_id_lookup = type_id_lookup
        return

    
    def findAll_DatasetPublishers(self):
        """ Publisher not exact, uses first element of str.split in URL"""
        selection = self.check_results()
        dataset_publishers = []
        publisher_id_lookup = {}

        for dataset in selection:
            d_id = dataset['dataset_id']
            
            # now use first ID , later integrate actual publisher tags,
            d_publisher = get_publisher(dataset)
            
            if d_publisher not in dataset_publishers:
                dataset_publishers.append(d_publisher)
                publisher_id_lookup.update({d_publisher: [dataset]})
            else:
                publisher_id_lookup[d_publisher].append(dataset)

        self.dataset_publishers = dataset_publishers
        self.publisher_id_lookup = publisher_id_lookup
        return


    def findAll_Tags(self):
        """ Tags are provided in their own list format"""
        
        if self.filterTagAndRB.isChecked():
            selection = self.check_results()
        else:
            # if not in AND mode, use all datasets in catalog
            selection = self.catalog

        # For all Tags, reverse lookup ability
        all_tags = []
        tag_id_lookup = {}
        
        for dataset in selection:
            d_tags = dataset['tags']
            # This will reorg the tags to look up all dataset id's 
            for tag in d_tags:
                if tag not in all_tags:
                    all_tags.append(tag)
                    tag_id_lookup.update({tag: [dataset]})
                else:
                    tag_id_lookup[tag].append(dataset)

        self.all_tags = all_tags
        self.tag_id_lookup = tag_id_lookup
        return


    def reorganize_catalog(self):
        """ Reorganize Catalog for avaliable dataset types/id's/tags """ 
        self.findAll_DatasetTypes()
        self.findAll_DatasetPublishers()
        self.findAll_Tags()
        return



    #=====================================
    # Create Drop Down Menu for dataset types
    #=====================================

    def setDropDown_DatasetType(self):
        """ Top Level Filter: 
        need to reset all other drop downs when this is changed"""
        self.filterDatasetTypeCB.clear()
        # First list item should be <blank> or '' for 'All' 
        self.filterDatasetTypeCB.addItem('')

        # run a quick update on the dataset types based on selection
        self.findAll_DatasetTypes()
        for dtype in self.dataset_types:
            self.filterDatasetTypeCB.addItem(str(dtype))

        # Somehow it needs to update filter options every time
        self.updateFilterOptions()

        return

    #=====================================
    # Create Drop Down Menu for Publisher:
    #=====================================

    def setDropDown_Publisher(self):
        self.filterDatasetPublisherCB.clear()
        # Default first option blank ('')
        self.filterDatasetPublisherCB.addItem('')

        # Run Update on all dataset publishers based on selection
        self.findAll_DatasetPublishers()
        for dpub in self.dataset_publishers:
            self.filterDatasetPublisherCB.addItem(str(dpub))

        return

    #=====================================
    # Create Tag list method
    #=====================================

    def setOptions_Tags(self):
        # tag search needs to be based off of 
        self.findAll_Tags()
        # completer = QCompleter(self.all_tags, self.filterTagSelectLE)
        completer = QCompleter(self.all_tags, self)
        self.filterTagSelectLE.setCompleter(completer)
        return
    

    #=====================================
    # UPDATES: Filtering in Real Time
    #=====================================

    def filterDatasetType(self):
        """ filter on dataset Type, skip if blank"""
        dd_type = self.filterDatasetTypeCB.currentText()
        if dd_type != '':
            selection = self.catalog
            filtered = []

            for dataset in selection:
                if dataset['dataset_type'] == dd_type:
                    filtered.append(dataset)

            self.results = filtered

        else:
            self.results = self.catalog

        return



    def filterPublisher(self):
        """ filter on Publisher drop down if blank skip"""

        dd_pub = self.filterDatasetPublisherCB.currentText()

        if dd_pub != '':
            selection = self.check_results()
            filtered = []

            for dataset in selection:
                dataset_pub = get_publisher(dataset)
                if dataset_pub == dd_pub:
                    filtered.append(dataset)

            self.results = filtered

        return



    def filterTags(self):
        """ filter on Tags in user's list, if blank skip """
        self.read_tags()

        if self.tag_list:
            selection = self.check_results()
            filtered = []

            for dataset in selection:
                # satisfied all, if just False once, ruins the AND case
                satisfied_all = True

                # satisfied one, just needs to succeed once, for OR case
                satisfied_one = False

                for tag in self.tag_list:
                    if tag not in dataset['tags']:
                        satisfied_all = False
                    
                    if tag in dataset['tags']:
                        satisfied_one = True


                if satisfied_one:
                    if self.filterTagAndRB.isChecked() and satisfied_all:
                        filtered.append(dataset)
                    elif self.filterTagOrRB.isChecked():
                        filtered.append(dataset)
                    else:
                        pass

            # Update the results, only if there was a tag list 
            self.results = filtered

        return



    def filterTime(self):
        """ Should Break each filter into own function... 
        Filter On Time"""

        selection = self.check_results()
        filtered = []

        filter_start = self.filterTimeStartDE.date()
        filter_end = self.filterTimeEndDE.date()

        for dataset in selection:
            start = convert_date(dataset['dataset_start'])
            end = convert_date(dataset['dataset_end'])

            if start is None or end is None:
                filtered.append(dataset)

            else:
                # QDate(year, month, day)
                start = QDate(start.year, start.month, start.day)

                # Now Get End Date
                if end == 'Present':
                    end = QDate.currentDate()
                    end = QDate(end.year(), end.month(), end.day())
                
                else:
                    end = QDate(end.year, end.month, end.day)


                # Last Check!

                if start <= filter_end and filter_start <= end:
                    filtered.append(dataset)


        # Update the attribute Results
        self.results = filtered

        return




    def filter_results(self):
        """ Order of Filter Operations: 
        1. Dataset Type (Image/ImageCollection/FeatureCollection)
        2. Publisher 
        3. Tags
        4. Time
        *NOTE: Location NEEDS MORE INFO from metadata"""

        # Filter 1: Dataset Type Drop Down Menu
        self.filterDatasetType()

        # Filter 2: Publisher Drop Down Menu
        self.filterPublisher()

        # Filter 3: Tags
        self.filterTags()

        # Filter 4: Time
        self.filterTime()

        # Now call those reorg functions
        self.reorganize_catalog()
        # self.beginningOfTime()
        # self.endOfTime()


        return
    

    #==============================================================

    def updateFilterOptions(self):
        """ Trigger When New Attribute Added to Filter to make Subset """
        self.filter_results()
        self.updateResultsList()
        self.setOptions_Tags()
        return

    def clearFilterOptions(self):
        """ Trigger When New Attribute Does not fit in Primary Dataset Type"""
        self.clearTagOptions()
        self.filter_results()
        self.updateResultsList()
        return

    def resetFilterOptions(self):
        """ Trigger When Primary Dataset Type Filter Altered"""
        self.filter_results()
        self.setDropDown_Publisher()
        self.updateResultsList()
        self.reorganize_catalog()
        return


    #==============================================================


    #==============================================================
    # Form Begin: Start/Reset 
    #============================================================== 
    
    #=====================================
    # Start Button
    #=====================================
    def Start(self):
        """ Run webscrape/file import to load GEE Catalog (metadata)"""
        # Initialize the catalog
        self.init_ee_catalog()

        # Initialize EE plugin
        self.init_ee_plugin()

        # Set Earliest Time
        self.beginningOfTime()
        # Now set the minimumDate for start from the total dataset
        self.filterTimeStartDE.setMinimumDate(self.filterTimeStartDE.date())

        # AutoFill the Drop Down if empty
        if self.filterDatasetTypeCB.count() == 0:
            self.setDropDown_DatasetType()

        if self.filterDatasetPublisherCB.count() == 0:
            self.setDropDown_Publisher()

        self.setOptions_Tags()

        # initialize the map
        base_layer_exists = False
        layers = QgsProject.instance().mapLayers()

        for name, layer in layers.items():
            if layer.name() == ('Google Satellite Hybrid') or layer.name() == ('Google Satellite'):
                base_layer_exists = True
                base_layer = layer

        if not base_layer_exists:
            base_layer = init_map()
            # Load a baselayer Raster to the QgsProject
            QgsProject.instance().addMapLayer(base_layer)

        QgsProject.instance().setCrs(base_layer.crs())
        return


    #=====================================
    # Reset Button
    #=====================================

    def Reset(self):
        """ Clear Session and saved metadata in form"""
        reset_msg = QMessageBox()
        reset_msg.setIcon(QMessageBox.Information)

        reset_msg.setText("Reseting Form")
        reset_msg.setInformativeText("Are you sure?")
        reset_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        response = reset_msg.exec()
        if response == QMessageBox.Yes:
            # Reset Procedure:
            # clear dataset type/publisher drop downs
            self.filterDatasetTypeCB.clear()
            self.filterDatasetPublisherCB.clear()

            # clear Tags (should already be a function)
            self.filterTagSelectLE.clear()

            # Time
            self.filterTimeDefaultCB.setCurrentText('')
            self.filterTimeEndDE.setMaximumDate(QDate.currentDate())
            self.filterTimeEndDE.setDate(QDate.currentDate())
            self.filterTimeStartDE.setMaximumDate(QDate.currentDate().addDays(-1))
            self.filterTimeStartDE.setDate(QDate(1980,1,1))

            # clear Lat/Lon
            self.locationSearchLatitudeLE.clear()
            self.locationSearchLongitudeLE.clear()

            # clear Radius and Import
            self.locationFilterRadiusLE.clear()
            self.locationFilterUnitKmRB.setChecked(True)

            # clear Results List View, and Tag List View
            m = QStandardItemModel()
            self.resultsSelectLV.setModel(m)
            self.filterTagSelectLV.setModel(m)

            # Set results counter to 0
            self.lcdNumber.display(0)

            # Extract
            self.extractResolutionLE.clear()
            self.extractBandSelectCB.clear()
            self.paletteSelectCB.clear()

            # Finally
            self.results = None
            self.filter_points = []
            self.features = []

            # Empty the extract data and request metadata
            self.extract_data = []
            self.extract_metadata = {}
            self.request_metadata = {}

            self.Start()
        return


    #==============================================================
    # END OF Form Begin Group
    #==============================================================


        #==============================================================
    # Attributes Group
    #==============================================================
    

    def change_on_dataset_type(self):
        """ specific handler of DatasetType Drop Down"""
        self.resetFilterOptions()
        return

    def change_on_publisher(self):
        """NOTE*: use clearFilterOptions, not Reset, when changing Publisher, just clear """
        self.clearFilterOptions()
        return


    def tagLogicSwitch(self):
        """ automatically switch to other Radio Button Mode OR|AND"""
        if self.filterTagOrRB.isChecked():
            self.filterTagAndRB.setChecked(False)
        elif self.filterTagAndRB.isChecked():
            self.filterTagOrRB.setChecked(False)
        else:
            pass
        
        self.Search()
        return

    
    def clearTagOptions(self):
        self.tag_list = []
        m = QStandardItemModel()
        self.filterTagSelectLV.setModel(m)
        self.filterTagSelectLE.clear()

        return

    #=====================================
    # Tag List View Model
    #===================================== 

    def read_tags(self):
        tag_list = []
        try:
            for i in range(self.filterTagSelectLV.model().rowCount()):
                if self.filterTagSelectLV.model().item(i).checkState() == Qt.Checked:
                    tag_list.append(self.filterTagSelectLV.model().item(i).text())

        except:
            pass

        self.tag_list = tag_list
        return




    def updateTagList(self):
        # Two cases for update: 
        # 1. (DEFAULT) OR: Add any tag and include all in search results
        # 2. (Need to check) AND: Live update Tag list, All tags must match in results

        tag_list = self.tag_list
        new_tag = self.filterTagSelectLE.text()
        AND_mode = self.filterTagAndRB.isChecked()
        try:
            # First, Assert this tag is in all tags ot begin with (OR + AND)
            assert new_tag in self.all_tags, "Tag Not in EE Catalog"

            if new_tag not in tag_list:
                tag_list.append(new_tag)
            # Now Display Tags in ListView 
            m_tags = QStandardItemModel()
            # Auto Clear each time:
            self.filterTagSelectLV.setModel(m_tags)
            
            # Repop List View
            for tag in tag_list:
                item = QStandardItem(tag)
                item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                item.setData(QVariant(Qt.Checked), Qt.CheckStateRole)
                m_tags.appendRow(item)

            self.tag_list = tag_list
            self.filterTagSelectLV.setModel(m_tags)
            self.filterTagSelectLE.clear()

            # when in AND mode, update the self.all_tags to only include tag overlap
            if AND_mode:
                # run update on results, find datasets with this tag
                selection = self.tag_id_lookup[new_tag]
                self.results = selection
                # Re-run the find_all functions, after filtering down results
                self.reorganize_catalog()
                # finally re-run set Options for autofilling
                self.setOptions_Tags()

            # Run the update
            self.updateFilterOptions()



        except Exception as e:
            # not really that important, but in case we need QMessage Info/Warning
            # THis Exception just prevents entering Tag before finished typing
            #QMessageBox.information(self, 'Unable to Add Tag', str(e.__class__) + ': ' + str(e), QMessageBox.Ok )
            pass

        return


    #==============================================================
    # END OF Attributes Group
    #==============================================================


    #==============================================================
    # Location Group
    #==============================================================

    # Use Public IP info to get Approximate Lat/Long
    def find_me(self):
        """ Plot the Point specified in Locaiton 
            Prompt User that IP is used
        if blank, then use IP Lat/Lon Approximation lookup"""
        # auth_msg = QMessageBox.information(QWidget, 'Information', 'Find Me function uses your Server IP location.\nDo you want to proceed?', (QMessageBox.Ok|QMessageBox.Cancel))
        auth_msg = QMessageBox()
        auth_msg.setIcon(QMessageBox.Information)
        auth_msg.setText("Find Me Authorization")
        auth_msg.setInformativeText("Method uses Server IP\n\n\nDo you wish to proceed?")
        auth_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        response = auth_msg.exec()
        if response == QMessageBox.Yes:
            if self.locationSearchLatitudeLE.text() == '' or self.locationSearchLongitudeLE == '':
                from .scripts import common
                loc = common.find_me()
                lat = loc['lat']
                lon = loc['lon']

                # Display Lat/Lon in LE entry boxes
                self.locationSearchLatitudeLE.setText(str(lat))
                self.locationSearchLongitudeLE.setText(str(lon))

            else:
                lat = float(self.locationSearchLatitudeLE.text())
                lon = float(self.locationSearchLongitudeLE.text())

            plot_point(lon, lat)
            center_point(lon, lat)
            return

    #==============================================================
    # END OF Location Group
    #==============================================================


    #==============================================================
    # GeoFilter Group
    #==============================================================

    def unitLogicSwitch(self):
        if self.locationFilterUnitKmRB.isChecked():
            self.locationFilterUnitMiRB.setChecked(False)
        elif self.locationFilterUnitMiRB.isChecked():
            self.locationFilterUnitKmRB.setChecked(False)
        else:
            pass

        return


    def generate_polygon_poi(self):
        from .scripts import common 
        lat = self.locationSearchLatitudeLE.text()
        lon = self.locationSearchLongitudeLE.text()
        radius = self.locationFilterRadiusLE.text()

        try:
            assert isinstance(float(lat), float), "Latitude Error"
            assert isinstance(float(lon), float), "Longitude Error"
            assert isinstance(float(radius), float), "Radius Error"
        except:
            QMessageBox.information(self, 'Missing Inputs', 'Cannot Create GeoFilter', QMessageBox.Ok)
            return

        else:
            unit = 'km' if self.locationFilterUnitKmRB.isChecked() else 'mi'

            default_sides = 6 if self.locationFilterGeometryCB.currentText() == 'Hexagon' else 0
            sides = 4 if self.locationFilterGeometryCB.currentText() == 'Rectangle' else default_sides

            lat = float(lat)
            lon =float(lon)

            radius = float(radius)
            point_list = common.GeneratePolygon(lat, lon, radius, unit, sides)
            plot_polygon(point_list)

            # Now use defined method to convert into Google Earth Engine Geometry
            points = {"geometry_id": "find_me_shape"}
            find_me_shape = {"points": len(point_list)}
            for n in range(0, len(point_list)):
                find_me_shape.update({n: point_list[n]})

            # add first == last to close the loop
            find_me_shape.update({len(point_list): point_list[0]})

            points["find_me_shape"] = find_me_shape

            if points not in self.filter_points:
                self.filter_points.append(points)

            features = []
            for points in self.filter_points:
                ee_shape = []
                pid = points['geometry_id']
                shape_points = points[pid]
                num_points = shape_points['points']
                for n in range(0, num_points):
                    pt = shape_points[n]
                    ee_shape.append([pt['longitude'], pt['latitude']])

                ee_poly = ee.Geometry.Polygon([ee_shape])
                ee_feat = ee.Feature(ee_poly, {'id': pid})
                features.append(ee_feat)


            self.ee_geometry_filters = ee.FeatureCollection(features)

            return


    def getSelectedGeometry(self):
        """ Get the coords for the selected polygon on active layer"""
        try:
            layer = qgis.utils.iface.activeLayer()
            # layer.selected()
            features = layer.selectedFeatures()
            # features = layer.getFeatures()
            self.features_to_points(features)

        except:
            QMessageBox.information(self, 'Information', 'No Shapes in Layer', QMessageBox.Ok)
            return



    def getAllGeometry(self):
        """ convert all shapes on active layer to EE """
        try:
            layer = qgis.utils.iface.activeLayer()
            layer.selectAll()
            features = layer.getFeatures()
            self.features_to_points(features)
        except:
            QMessageBox.information(self, 'Information', 'No Shapes in Layer', QMessageBox.Ok)
            return


    def features_to_points(self, features):
        """ Add a list of features as points in filter"""

        for feature in features:
            points = {"geometry_id": feature.id()}
            points[feature.id()] = {}
            geometry_handled = False
            geo = feature.geometry()

            # First Geometry type attempt: MultiPolygon
            try:
                Q_mp = geo.asMultiPolygon()
                points[feature.id()]['geometry_type'] = 'MultiPolygon'

                # First for loop is a sinlge list object
                count = 0
                for mp in Q_mp:
                    for poly in mp:
                        count += 1
                        count_poly = "Part_{}".format(count)
                        poi = get_points(poly)
                        points[feature.id()][count_poly] = poi

                
                points[feature.id()]['Parts'] = count

                geometry_handled = True

            except:
                pass

            
            # Second Attempt: regular Single Polygon
            try:
                assert not geometry_handled, "Do not proceed"
                Q_POLY = geo.asPolygon()
                points[feature.id()]['geometry_type'] = 'Polygon'
                # For QgsPolygon Class, this creates a list
                for poly in Q_POLY:
                    # now we are at the Actual Polygon, iterate through points
                    poi = get_points(poly)

                points[feature.id()]['Points'] = poi
                geometry_handled = True
            except:
                pass


            # Final Attempt: PolyLine
            try:
                assert not geometry_handled, "Do not proceed"
                poi = get_points(geo.asPolyline())
                points[feature.id()]['geometry_type'] = 'Polygon'
                points[feature.id()]['Points'] = poi
                geometry_handled = True

            except:
                pass


            try:
                assert geometry_handled, "Geometry Not Included"
                if points not in self.filter_points:
                    self.filter_points.append(points)

            except Exception as e:
                QMessageBox.information(self, str(e), "{}".format(geo), QMessageBox.Ok)
                return

        return


    def clearGeometryFilter(self):
        """ Clear out the geometry from previous filters"""
        if self.filter_points == []:
            QMessageBox.information(self, 'Information', 'No Geometric Filters', QMessageBox.Ok)
        else:
            reset_msg = QMessageBox()
            reset_msg.setIcon(QMessageBox.Information)
            reset_msg.setText("Are you sure?")
            reset_msg.setInformativeText("Clear {} Geometric Filter(s) in this Active Layer?".format(len(self.filter_points)))
            reset_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            response = reset_msg.exec()
            if response == QMessageBox.Yes:
                self.filter_points = []

        return

    #==============================================================
    # END OF GeoFilter Group
    #==============================================================


    #==============================================================
    # Time Group
    #==============================================================

    def beginningOfTime(self, set_date=True):
        """ Find the First date in the current selection of results/catalog"""
        selection = self.check_results()

        if selection:
            min_date = QDate.currentDate().addDays(1)
        
            for dataset in selection:
                date = convert_date(dataset['dataset_start'])

                if date is not None:
                    dataset_date = QDate(date.year, date.month, date.day)
                    if dataset_date < min_date:
                        min_date = dataset_date


            # IF min date remains the same, warning, no dates found
            if min_date == QDate.currentDate().addDays(1):
                self.no_dates_found()

            # if new min was set, and we want to set the form, check flag
            elif set_date:
                self.filterTimeStartDE.setDate(min_date)
                # self.filterTimeCustomRB.setChecked(True)
                return self.filterTimeStartDE.date()

            # if we don't want to set the form, just return the min date
            else:
                return min_date

        # if there was no selection, just return value of the set start
        else:
            return self.filterTimeStartDE.date()


    def endOfTime(self, set_date=True):
        """ Find the Last date in the current selection of results/catalog"""
        selection = self.check_results()

        if selection:
            max_date = self.filterTimeStartDE.date().addDays(-1)

        
            for dataset in selection:
                date = convert_date(dataset['dataset_end'])


                if date == 'Present':
                    max_date = QDate.currentDate()
                    break

                elif date is None:
                    max_date = QDate.currentDate()
                    break

                else:
                    # QDate(year, month, day)
                    dataset_date = QDate(date.year, date.month, date.day)
                    if dataset_date > max_date:
                        max_date = dataset_date


            # Last Validation, if the max_date is same as the initial max, don't change
            if max_date == self.filterTimeStartDE.date().addDays(-1):
                max_date = self.filterTimeEndDE.date()



            elif set_date:
                self.filterTimeEndDE.setDate(max_date)
                # self.filterTimeCustomRB.setChecked(True)


            else:
                return max_date

        else:
            max_date = self.filterTimeEndDE.date()
            return max_date


    def date_validation(self, auto_fix=True):
        """ Run this every time Search is clicked, to throw warning if dates
        Are not valid for dataset list, and automatically snap to boundary"""
        
        selection = self.catalog

        filter_start = self.filterTimeStartDE.date()
        valid_start = self.beginningOfTime(set_date=False)


        if filter_start < valid_start and auto_fix:
            self.filterTimeStartDE.setDate(valid_start)

        filter_end = self.filterTimeEndDE.date()
        valid_end = self.endOfTime(set_date=False)

        try:
            if filter_end > valid_end and auto_fix:
                self.filterTimeEndDE.setDate(valid_end)
        except TypeError as e:
            self.date_out_of_range()

        return

    def change_start_date(self):
        """ dynamically set new Minimum for end based on changed start"""
        old_end = self.filterTimeEndDE.date()
        new_start = self.filterTimeStartDE.date()
        if old_end < new_start:
            self.filterTimeEndDE.setDate(new_start.addDays(1))
        return

    def date_out_of_range(self):
        QMessageBox.information(self, 'Warning: Invalid Date', 'Date Out of Range: ' + str(self.filterTimeStartDE.date()), QMessageBox.Ok )

    def no_dates_found(self):
        QMessageBox.information(self, 'Warning: Missing Dates', 'No Dates Found in Results', QMessageBox.Ok)


    def handle_time(self):
        """ Drop Down menu for common options time filter """
        time_window = self.filterTimeDefaultCB.currentText()
        if time_window == '1D':
            self.dayOne()
        elif time_window == '7D':
            self.daySeven()
        elif time_window == '1M':
            self.monthOne()
        elif time_window == '3M':
            self.monthThree()
        elif time_window == '6M':
            self.monthSix()
        elif time_window == '1Y':
            self.yearOne()
        elif time_window == 'YTD':
            self.yearToDate()
        else:
            pass

    def yearToDate(self):
        """ This Button Will have the only override mechanism to set
        End Date to Current date automatically """
        # self.timeLogicSwitch()
        self.filterTimeEndDE.setDate(QDate.currentDate())
        self.filterTimeStartDE.setDate(QDate(QDate.currentDate().year(), 1, 1))
        return

    def yearOne(self):
        new_start = self.filterTimeEndDE.date().addMonths(-12)
        if new_start >= self.filterTimeStartDE.minimumDate():
            # self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            # self.filterTimeCustomRB.setChecked(True)
            self.filterTimeDefaultCB.setCurrentText('')

    def monthSix(self):
        new_start = self.filterTimeEndDE.date().addMonths(-6)
        if new_start >= self.filterTimeStartDE.minimumDate():
            # self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            # self.filterTimeCustomRB.setChecked(True)
            self.filterTimeDefaultCB.setCurrentText('')

    def monthThree(self):
        new_start = self.filterTimeEndDE.date().addMonths(-3)
        if new_start >= self.filterTimeStartDE.minimumDate():
            # self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            # self.filterTimeCustomRB.setChecked(True)
            self.filterTimeDefaultCB.setCurrentText('')

    def monthOne(self):
        new_start = self.filterTimeEndDE.date().addMonths(-1)
        if new_start >= self.filterTimeStartDE.minimumDate():
            # self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            # self.filterTimeCustomRB.setChecked(True)
            self.filterTimeDefaultCB.setCurrentText('')

    def daySeven(self):
        new_start = self.filterTimeEndDE.date().addDays(-7)
        if new_start >= self.filterTimeStartDE.minimumDate():
            # self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            # self.filterTimeCustomRB.setChecked(True)
            self.filterTimeDefaultCB.setCurrentText('')

    def dayOne(self):
        new_start = self.filterTimeEndDE.date().addDays(-1)
        if new_start >= self.filterTimeStartDE.minimumDate():
            # self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            # self.filterTimeCustomRB.setChecked(True)
            self.filterTimeDefaultCB.setCurrentText('')

    #==============================================================
    # END OF Time Group
    #==============================================================

    #==============================================================
    # Search/Results
    #==============================================================

    def Search(self):
        """ The Actual Search Button"""
        # Validate Parameters
        self.date_validation()
        
        # Start from full catalog each time
        self.results = self.catalog

        # reorg
        self.reorganize_catalog()

        # filter using all
        self.filter_results()

        # update List View of Results
        self.updateResultsList()


    #=====================================
    # Results ListView
    #===================================== 

    def updateResultsList(self):
        """ Update List View for Current Results"""
        # Instantiate List View Model, from clear state each time
        m = QStandardItemModel()
        self.resultsSelectLV.setModel(m)
        
        selection = self.check_results()
        for dataset in selection:
            item = QStandardItem(dataset['dataset_id'] + '\t ('+str(dataset['dataset_type']) + ')' )
            item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            item.setData(QVariant(Qt.Checked), Qt.CheckStateRole)
            m.appendRow(item)
        
        self.resultsSelectLV.setModel(m)

        # Display Results Count
        self.lcdNumber.display(len(self.results))
        return

    #=====================================
    # Results Button Selection
    #===================================== 

    def count_results(self):
        count = 0
        for i in range(self.resultsSelectLV.model().rowCount()):
            if self.resultsSelectLV.model().item(i).checkState() == Qt.Checked:
                count += 1
        self.lcdNumber.display(count)


    def clear_results(self):
        """deselect all items of the list view widget"""
        for i in range(self.resultsSelectLV.model().rowCount()):
            self.resultsSelectLV.model().item(i).setCheckState(Qt.Unchecked) 
        
        self.lcdNumber.display(0)


    def read_results(self):
        """ Read the list view and update the self.results"""
        results_list = []

        try:
            for i in range(self.resultsSelectLV.model().rowCount()):
                if self.resultsSelectLV.model().item(i).checkState() == Qt.Checked:
                    results_list.append(self.resultsSelectLV.model().item(i).text().split('\t')[0])
        except:
            self.results = results_list
            self.lcdNumber.display(len(results_list))

        else:
            real_data = []
            for dataset in self.catalog:
                if dataset['dataset_id'] in results_list:
                    real_data.append(dataset)
            self.results = real_data
            self.lcdNumber.display(len(real_data))

        return
    


    def select_result(self):
        """ Use this method as a means to gather metadata and perform checks before
        extracting with request to Google Earth Engine (Use to Replace AutoFill)
        Use before Extracting Data to Save or Add as a Layer on Map"""

        # 1. Read Results from Table
        self.read_results()
        # Check 1: Assert 1 dataset per Query
        try:
            assert len(self.results) <= 1, "Please Limit Selection to 1"
            result = self.results[0]     

        except Exception as e:
            QMessageBox.information(self, 'In Development', str(e), QMessageBox.Ok)
            return

        # for result in self.results:
        # 2a. Validate the start Date
        test_start = self.beginningOfTime(set_date=False).toString('yyyy-MM-dd')
        
        # 2b. set an end date to extract sample of getInfo()
        test_end = add_string_days(test_start, 1)
        
        # 2c. use test filter boundary
        aoi = self.validate_geometry(result)

        # 3. needs to be handled differently per dataset type
        dataset_type = result['dataset_type']
        dataset_id = result['dataset_id']

        # Now extract the info with getInfo() method  
        if dataset_type == 'Image':
            QMessageBox.information(self, 'Information', 'In Development', QMessageBox.Ok)
            return 

        elif dataset_type == 'ImageCollection':
            # IC = ee.ImageCollection(dataset_id).filterDate(test_start, test_end)
            
            # # Filter with User Boundary if defined
            # if aoi is not None:
            #     IC = IC.filterBounds(aoi)
            # info = IC.getInfo()

            info = self.get_info_preview(result)

            band_info = process_IC_band_info(info)
            visParams = process_IC_palette(info)
            # Band Drop Down Menu
            self.extractBandSelectCB.clear()
            self.extractBandSelectCB.addItem('')
            for band in band_info:
                self.extractBandSelectCB.addItem(band['id'])

            # Default Visualization Options
            if 'palette' in visParams:
                # band_info['data_type']['palette'] = visParams['palette']
                enter_palette = "{}: {}".format(visParams['bands'][0], ",".join(visParams['palette']))        
                self.paletteSelectCB.clear()
                self.paletteSelectCB.addItem(enter_palette)


        elif dataset_type == 'FeatureCollection':
            # QMessageBox.information(self, 'Information', 'Does Not Apply to Feature Collection', QMessageBox.Ok)
            band_info = []
            visParams = {}
       
        
        else:
            QMessageBox.information(self, 'Warning', 'Undefined Dataset {}'.format(dataset_type), QMessageBox.Ok)

        
        self.extract_metadata = {'band_info': band_info, 'visParams': visParams}

        return


    def getDetails(self):
        """ ? BTN action, get all description from dataset"""
        self.read_results()

        # 1. Enforce Single Result lookup for now
        result = self.results[0]

        # for result in self.results:
        dataset_id = result['dataset_id']
        dataset_type = result['dataset_type']

        try:
            info = self.get_info_preview(result)
            about_description = info['properties']['description']

        except:
            about_description = "FULL DESCRIPTION MISSING FROM EARTH ENGINE\n\nBrief Description from Webscrape:\n"
            for k, v in result.items():
                about_description = about_description + "\n\n{}:\t{}".format(k,v)
        finally:
            self.openAboutInfo(about_description)



        return


    def openAboutInfo(self, text):
        """ Scroll Box Message Pop Up from getInfo details call"""
        about = QMessageBox()
        about.setWindowTitle("About Dataset")
        lines = len(text.split("\n"))

        if lines > 25:
            scroll = QScrollArea()
            scroll.setWidgetResizable(1)
            content = QWidget()
            scroll.setWidget(content)
            layout = QVBoxLayout(content)
            qtext = QtWidgets.QLabel(text)
            layout.addWidget(qtext)

            # layout.addWidget(QtWidgets.QTableWidget(text))
            # layout.addWidget(QtWidgets.QFrame(text))
            about.layout().addWidget(scroll, 0, 0, 1, about.layout().columnCount())
            about.setStyleSheet("QScrollArea{min-width:1080 px; min-height: 800px}")
            about.exec_()
        else:
            about.information(self, 'About Dataset', text, QMessageBox.Ok)

        return

    #==============================================================
    # END OF Results Group
    #==============================================================

    #==============================================================
    # START OF EXTRACT Group
    #==============================================================


    def create_request(self):
        """ Use this method as a means to gather metadata and perform checks before
        extracting with request to Google Earth Engine (Use to Replace AutoFill)
        Use before Extracting Data to Save or Add as a Layer on Map"""
        
        # Request Metadata will be saved and Ouput to send, each step will add 
        # an attribute, and failure will help user understand what filter is missing
        request_metadata = {}
        # 0. If user has not Hit Select Button:

        # Only need to Read Results from Table
        self.read_results()
        
        # Check 1: Assert 1 dataset per Query
        try:
            assert len(self.results) <= 1, "Please Limit Selection to 1"
            result = self.results[0]     

        except Exception as e:
            QMessageBox.information(self, 'In Development', str(e), QMessageBox.Ok)
            return request_metadata


        # needs to be handled differently per dataset type
        # Add first details to request
        dataset_type = result['dataset_type']
        request_metadata['dataset_type'] = dataset_type
        
        dataset_id = result['dataset_id']
        request_metadata['id'] = dataset_id

                  
        if dataset_type == 'Image':
            return request_metadata

        elif dataset_type == 'ImageCollection':
            # Check: Assert a Band is selected
            band = self.extractBandSelectCB.currentText()
            request_metadata['bands'] = band
            if band == "":
                # QMessageBox.information(self, 'Required', 'Please Select a Band', QMessageBox.Ok)
                # Run the select result function to populate Band Selection Combo Box
                self.select_result()
                request_metadata['missing_parameter'] = 'Please Select a Band'
                return request_metadata

            # It is not possible to make it this far unless "band" has been selected
            # This is required in select result phase
            band_info = self.extract_metadata['band_info']
            crs = ""
            for info in band_info:
                if info['id'] == band:
                    crs = info['crs']

            request_metadata['crs'] = crs

                        
            # Check: Assert Resolution is set
            if self.extractResolutionLE.text() == "":
                # QMessageBox.information(self, "Required", "Set Resolution", QMessageBox.Ok)
                request_metadata['missing_parameter'] = 'Resolution Required'
                return request_metadata
            else:
                resolution = float(self.extractResolutionLE.text())


        
        elif dataset_type == 'FeatureCollection':
            # QMessageBox.information(self, 'Information', 'Does Not Apply to Feature Collection', QMessageBox.Ok)
            # Not really an issue for Feature Collections as far as I know
            request_metadata['bands'] = ""
            request_metadata['crs'] = ""
            resolution = 0 
    
        
        else:
            QMessageBox.information(self, 'Warning', 'Undefined Dataset {}'.format(dataset_type), QMessageBox.Ok)
        

        start = self.filterTimeStartDE.text()
        end = self.filterTimeEndDE.text()


        # Each Dataset has a BBox, use this to set default Geometry Filter and find
        # Intersection if user's Polygon is outside of the scope
        aoi = self.validate_geometry(result)

        # Final update to request metadata
        request_metadata.update({
                            'start': start,
                            'end': end,
                            'request_complete': False,
                            'request_attempt': False,
                            'geometry_filter': aoi,
                            'resolution':resolution
                })

        return request_metadata


    def send_request(self, request):
        """ Use to attempt extract data process
        
        Example to show area:
        ee_area_m2 = aoi.area().getInfo()
        ee_area_km2 = round(ee_area_m2/1000000, 2) 
        
        Limit for dataframe rows: 1048576
        Trigger Exception to resize """

        try:
            # Get Parameters from Request:
            # request = self.request_metadata
            # 1a. Band
            selected_band = request["bands"]

            # 1b. Extract Data Type and ID
            dataset_type = request['dataset_type']
            dataset_id = request['id']

            # 1c. Time Filters
            start = request['start']
            end = request['end']

            # 1d. Get CRS and Resolution
            crs = request['crs']
            resolution = request['resolution']

            # 2. Geo Filter
            aoi = request['geometry_filter']

            # Send Request to Earth Engine to Extract
            if dataset_type == 'Image':
                ee_data = ee.Image(dataset_id).select(selected_band)

            elif dataset_type == 'ImageCollection':
                ee_collection = ee.ImageCollection(dataset_id).filterDate(start, end)
                ee_collection = ee_collection.select(selected_band)
                ee_collection_region = ee_collection.getRegion(aoi, resolution, crs)
                ee_collection_info = ee_collection_region.getInfo()
                ee_data = ee_collection.getRegion(aoi, resolution, crs).getInfo()
                self.process_IC_data(ee_data, request) 
                
            elif dataset_type == 'FeatureCollection':
                FC = ee.FeatureCollection(dataset_id) #.filterDate(start, end)
                FC_data = FC.filterBounds(aoi)
                ee_data = FC_data.getInfo()
                self.process_FC_data(ee_data)

            else:
                self.extract_data = []

            # Not actually using this yet
            request['request_attempt'] = True
            request['request_complete'] = True


        except KeyError as error:
            QMessageBox.information(self, 'Error', 'Unable to Process Request\nPossible Missing Request Parameter: {}'.format(error), QMessageBox.Ok)
            self.extract_data = []

        except Exception as error:
            self.AutoResize(request, error)
            self.extract_data = []
            # Not Actually using this yet
            request['request_attempt'] = True
            request['request_complete'] = False

        return




    def process_IC_data(self, ee_data, request):
        """ data from Earth Engine is a simple list of lists as Image Collection """
        all_request_data = []
        columns = ee_data[0]
        for row in ee_data[1:]:
            req_data = {}
            for n in range(0, len(columns)):
                col = columns[n]
                val = row[n]
                try:
                    if col == 'id':
                        req_data['img_datetime_start'] = image_time(val.split('_')[0])
                        req_data['img_datetime_stop'] = image_time(val.split('_')[1])
                except:
                    pass

                req_data[col] = val
            # Fill in Gaps
            req_data['Resolution(m)'] = request['resolution']
            req_data['CRS'] = request['crs']
            req_data['dataset_id'] = request['id']
            req_data['dataset_type'] = request['dataset_type']
            req_data['filter_start'] = request['start']
            req_data['filter_end'] = request['end']
            req_data['filter_band'] = request['bands']

            all_request_data.append(req_data)

        # now store this extracted data from specific request in list of all data
        self.extract_data = all_request_data


    def process_FC_data(self, ee_data):
        """ data from Feature Collection is list of dictionaries"""
        # Do nothing, FC is either list of dictionaries or already formatted as geojson/json
        self.extract_data = ee_data


    def Extract(self):
        """ Use this method to extract data in order to either save or add the layer next"""

        # 0. Check if self.extract_data already full
        if self.extract_data != []:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText('Previous Extraction Data ')
            msg.setInformativeText('{} Datapoints Returned\n\nSave Extracted Data Before Next Request'.format(len(self.extract_data)))
            msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            response = msg.exec()
            if response != QMessageBox.Ok:
                # If user Cancels Store Data for now:
                final_response = QMessageBox.information(self, 'Warning', "Clearing Previous Request", QMessageBox.Ok|QMessageBox.Cancel)    
                if final_response == QMessageBox.Ok:
                    self.extract_data = []
                else:
                    return
            else:
                fn = self.saveResults()
                if fn is not None:
                    plot_vector(fn)
                    self.extract_data = []
                else:
                    return


        # 1a. Start by creating request from selected result 
        request = self.create_request()

        # 1b. Check if results were returned
        if 'missing_parameter' in request:
            error_msg = "Request Metadata:\n"
            for key, val in request.items():
                error_msg = error_msg + "\n{}: \t{}\n".format(key, val)
            QMessageBox.information(self, 'Error', 'No Data Returned from Google Earth Engine:\n{}'.format(error_msg), QMessageBox.Ok)
            return

        # 2a. Send Request, attempt will give recommendations upon failure
        self.send_request(request)

        # 2b. Check if results were returned
        if self.extract_data == []:
            error_msg = "Request Metadata:\n"
            for key, val in request.items():
                error_msg = error_msg + "\n{}: \t{}\n".format(key, val)
            QMessageBox.information(self, 'Error', 'No Data Returned from Google Earth Engine:\n{}'.format(error_msg), QMessageBox.Ok)
            return

        success_msg = QMessageBox()
        success_msg.setIcon(QMessageBox.Information)
        success_msg.setText('Image Collection Extraction Complete')
        success_msg.setInformativeText('{} Datapoints Returned\n\nSaving Extracted Data Now...'.format(len(self.extract_data)))
        success_msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        response = success_msg.exec()
        if response == QMessageBox.Ok:
            fn = self.saveResults()
            if fn is not None:
                plot_vector(fn)
                self.extract_data = []

        return



    def apply_palette(self):
        """ based on default in Collection from selected band in drop down menu"""
        # Check 1: if there is no selection on palette
        if self.paletteSelectCB.currentText() == "":
            return

        # Check 2: No Default in metadata
        visParams = self.extract_metadata['visParams']
        if visParams == {}:
            return
       
        # Check 3: no band selected
        selected_band = self.extractBandSelectCB.currentText()
        if selected_band == "":
            return
        
        # Check 4: No palette in VisParams (need to work on Gamma value)
        if 'palette' not in visParams:
            return
        
        else:          
            # Build Q Color Gradient Layer
            # Convert Colors to Hex/or Valid QColor strings
            q_colors = []
            for color in visParams['palette']:
                if is_hex(color):
                    color = "#"+color
                    q_colors.append(color)
                elif QColor.isValidColor(color):
                    q_colors.append(color)
                else:
                    QMessageBox.information(self, 'Warning', 'INVALID COLOR: {}'.format(color), QMessageBox.Ok)
                    q_colors.append(color)

        try:
            # Now adjust layer to use visualization
            layer = qgis.utils.iface.activeLayer()

            vals = []
            fld = selected_band
            
            for f in layer.getFeatures():
                # Check 5: Ensure User has selected correct layer
                assert fld in f, "Select the Correct Layer to Apply Palette"
                vals.append(f[fld])

            # Filter Null
            vals = (list(filter(None, vals)))
            
            # This is for Vector Layer
            # Find the Min of this set or use
            min_local = float(sorted(vals)[0])
            max_local = float(sorted(vals)[-1])
            interval = (max_local - min_local)/len(q_colors)

            range_list = []
            # build list to shade colors                
            for n in range(0, len(q_colors)):
                color = q_colors[n]
                cat = [min_local+(interval*n), min_local+(interval*(n+1)), color]
                sym = QgsSymbol.defaultSymbol(layer.geometryType())
                sym.setColor(QColor(cat[2]))
                rng = QgsRendererRange(cat[0], cat[1], sym, '{0:.5f}-{1:.5f}'.format(cat[0], cat[1]))
                range_list.append(rng)


            renderer = QgsGraduatedSymbolRenderer(fld, range_list)
            layer.setRenderer(renderer)
            layer.triggerRepaint()

        except Exception as e:
            QMessageBox.information(self, 'Warning', str(e), QMessageBox.Ok)

        return


    def saveResults(self):
        """open file dialog to select exising csv/text file and if accepted, update GUI accordingly"""
        from .scripts import file_handler
        # For now, only supporting .shp, next look at GeoPackage/GeoJson/CSV list of points
        if isinstance(self.extract_data, dict):
            supported_fileTypes = ['.geojson', '.json'] #, '.shp', '.gpkg']
            unravel = False
        else:
            supported_fileTypes = ['.geojson', '.csv', '.json'] 
            unravel = True


        try:
            fileName, fileType = QFileDialog.getSaveFileName(self, "Select Folder", "", ";;".join(supported_fileTypes))
            assert fileName != "", "No File Name Set"
        except:
            return

        # If User enters Filename including .<fileType>, don't add it twice
        user_type_fileType = '.' + fileName.split('.')[-1]
        fn = fileName if user_type_fileType == fileType else fileName + fileType          



        try:        
            assert fileType in supported_fileTypes, 'Unsupported File Type: {}\n Try: {}'.format(fileType, supported_fileTypes)
            save_data = self.extract_data

            if fileType == '.csv':

                with open(fn, 'w', newline='') as fw:
                    csvwriter = csv.writer(fw)
                    csvwriter.writerow(save_data[0].keys())
                    for rw in save_data:
                        csvwriter.writerow(rw.values())

            elif fileType == '.json':
                with open(fn, 'w') as fw:
                    json.dump(save_data, fw, indent=4)

            elif fileType == '.geojson':
                try:
                    # This is used when resolution is set for Image/Image Collections
                    resolution = float(self.extractResolutionLE.text())
                except:
                    resolution = 0
                
                if unravel:
                    save_geojson = json_to_geojson(save_data, lat='latitude', lon='longitude', resolution=resolution)
                else:
                    save_geojson = save_data

                with open(fn, 'w') as fw:
                    geojson.dump(save_geojson, fw, indent=4)

            else:
                QMessageBox.information(self, 'Error: Failed to Save', 'Unsupported File Type: {}'.format(fileType), QMessageBox.Ok)
                return

            return fn

            
        except Exception as e:
            QMessageBox.information(self, 'Error: Failed to Save', str(e), QMessageBox.Ok)
            return


    #==============================================================
    # END OF EXTRACT Group
    #==============================================================









    #==============================================================
    # Automation Group
    #==============================================================

    def get_visualization(self, dataset):
        """ for image collection"""
        start = self.filterTimeStartDE.text()
        fake_end = add_string_days(start, 1)

        dataset_id = dataset['dataset_id']
        dataset_type = dataset['dataset_type']

        viz = {}
        info = {}

        if dataset_type == 'ImageCollection':
            IC = ee.ImageCollection(dataset_id).filterDate(start, fake_end)
            info = IC.getInfo()

        elif dataset_type == 'Image':
            image = ee.Image(dataset_id)
            info = image.getInfo()

        elif dataset_type == 'FeatureCollection':
            return viz

        else:
            return viz

        for key, val in info["properties"].items():
            if "visualization" in key:
                viz[key] = val

        band_key = '0'        
        viz_min = None
        viz_max = None
        viz_palette = []
        viz_name = None
        viz_band_select = None
        all_visParams = {}
        
        # First eliminate all 'system' keys from info properties
        for key, val in viz.items():
            if 'system' not in key:
                new_key = key.split('_')[-1]

                try:
                    val = float(val)
                except:
                    pass
                finally:
                    all_visParams[new_key] = val

        visParams = {}
        for key, val in all_visParams.items():
            skip = False
            if 'max' == key:
                val = float(val)
            elif 'min' == key:
                val = float(val)
            elif 'palette' == key:
                val = [str(color) for color in val.split(',')]
            elif 'bands' == key:
                val = [val]
            elif 'gamma' == key:
                val = float(val)
            elif 'name' in key:
                skip = True
            else:
                pass

            if not skip:
                visParams[key] = val
                skip = True


        if 'palette' in visParams:
            # band_info['data_type']['palette'] = visParams['palette']
            enter_palette = "{}: {}".format(visParams['bands'][0], ",".join(visParams['palette']))        
            self.paletteSelectCB.clear()
            self.paletteSelectCB.addItem(enter_palette)

        
        return visParams



    def get_bands(self, result):
        """ **UPDATE: Use specific Result as input from resutls table for a dataset ID and extracts the list of Bands
        Available in Dataset, then lists in the drop down menu in the Extract Group"""

        # for result in self.results:
        # 2a. Validate the start Date
        test_start = self.beginningOfTime(set_date=False).toString('yyyy-MM-dd')
        # 2b. set an end date to extract sample of getInfo()
        test_end = add_string_days(test_start, 1)
        # 2c. use test filter boundary
        aoi = self.validate_geometry(result)

        # 3. needs to be handled differently per dataset type
        dataset_type = result['dataset_type']
        dataset_id = result['dataset_id']

        # Now extract the info with getInfo() method
                
        if dataset_type == 'Image':
            image = ee.Image(dataset_id)
            info = image.getInfo()
            band_info = info['bands']

        elif dataset_type == 'ImageCollection':
            IC = ee.ImageCollection(dataset_id).filterDate(test_start, test_end)
            IC_bound = IC.filterBounds(aoi)
            info = IC_bound.getInfo()
            # For the ImageCollection, The Bands are found within the Features 
            # Attribute of the result getInfo() method, this is a list which contains a dictionary.
            try:
                band_info = info['features'][0]['bands']
            except IndexError:
                ans = QMessageBox.information(self, 'Response Empty', 'Bands in Image: {}\n\nFeatures in Request: {}\n\nTry Adjusting Date Filters or Location on Map\n\nWould You Like More Help for this dataset?'.format(info['bands'], info['features']), QMessageBox.Yes|QMessageBox.No)
                if ans == QMessageBox.Yes:
                    self.getDetails()
                return

        elif dataset_type == 'FeatureCollection':
            QMessageBox.information(self, 'Information', 'Does Not Apply to Feature Collection', QMessageBox.Ok)
            return            
        
        else:
            QMessageBox.information(self, 'Warning', 'Undefined Dataset {}'.format(dataset_type), QMessageBox.Ok)

        # Handle the Band Info, adding each band to the list.
        self.extractBandSelectCB.clear()
        self.extractBandSelectCB.addItem('')
        for band in band_info:
            self.extractBandSelectCB.addItem(band['id'])

        return


    def get_info_preview(self, result):
        """Use this to extract geometry scope of dataset """
        start = self.beginningOfTime(set_date=False).toString('yyyy-MM-dd')
        # 2b. set an end date to extract sample of getInfo()
        # use two days to get full area
        test_start = add_string_days(start, 0)
        test_end = add_string_days(start, 1)

        # 3. needs to be handled differently per dataset type
        dataset_type = result['dataset_type']
        dataset_id = result['dataset_id']

        # Now extract the info with getInfo() method        
        if dataset_type == 'Image':
            pass

        elif dataset_type == 'ImageCollection':
            IC = ee.ImageCollection(dataset_id)
            IC_filt = IC.filterDate(test_start, test_end)
            info = IC_filt.getInfo()
            if info['features'] == []:
                first_image = IC.first().getInfo()
                first_image_id = first_image['properties']['system:index']
                actual_start = first_image_id.split('_')[0]
                test_end = add_string_days(actual_start, 1)

                # Use fake boundary
                use_bound = ee.Geometry.Rectangle([-80.25, 40, -80, 40.1]) # Based in Pittsburgh, PA, USA
                IC_filt = IC.filterBounds(use_bound).filterDate(start, test_end)
                info = IC_filt.getInfo()

        elif dataset_type == 'FeatureCollection':
            use_bound = ee.Geometry.Rectangle([-80.25, 40, -80, 40.1]) # Based in Pittsburgh, PA, USA
            FC = ee.FeatureCollection(dataset_id).filterBounds(use_bound)
            info = FC.getInfo()
          
        else:
            pass

        return info



    def validate_geometry(self, result):
        """ Use this to check if Filter points exist and are within scope of Dataset"""
        # Cleanest way to implement, clear self.filter_points and create selected geometry
        self.filter_points = []

        # This will create a filter based on Selected Geometry from Active Map Layer
        self.getSelectedGeometry()

        try:
            if self.filter_points == []:
                info_msg = QMessageBox()
                info_msg.setIcon(QMessageBox.Information)
                info_msg.setText("Warning, No Geometry Filter Applied")
                info_msg.setInformativeText("Use No Filter?")
                info_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                response = info_msg.exec()
                if response != QMessageBox.Yes:
                    return
                else:
                    info = self.get_info_preview(result)
                    geometry_filters = process_IC_geometry(info)
                    area_of_interest = geometry_filters.geometry()

            else:
                geometry_filters = QGIS_to_GEE_Geometry(self.filter_points)
                area_of_interest = geometry_filters.geometry()

                preview_info = self.get_info_preview(result)
                total_footprint = process_IC_geometry(preview_info)
                dataset_footprint = total_footprint.geometry()
                margin = 1000
                intersect_aoi = dataset_footprint.intersection(area_of_interest, ee.ErrorMargin(margin))
                area_intersect = intersect_aoi.area().getInfo()

                area_user = area_of_interest.area().getInfo()
                   

            return area_of_interest


        except Exception as e:
            # QMessageBox.information(self, 'Warning', str(e), QMessageBox.Ok)
             QMessageBox.information(self, 'Warning', 'This Image does not have data in your selected GeoFilter', QMessageBox.Ok)
             return None


    def AutoResize(self, request, error):
        """ Attempt at auto resolving request too large """
        error_msg = QMessageBox()
        error_msg.setIcon(QMessageBox.Information)

        error_msg.setText("Earth Engine Error")
        error_msg.setInformativeText("{}\n\nGet Help to Resize Request?".format(error))
        error_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        response = error_msg.exec()
        
        if response != QMessageBox.Yes:
            return
        
        try:
            msg = "{}".format(error)
            if msg.split(': ')[1] == 'Too many values':
                numeric_info = msg.split(': ')[2]
                # example of 'numeric_info'
                # 658739 points x 1 bands x 4 images > 1048576.
                
                # extract everything beyond Greater Than sign, including '.' use float -> int
                request_limit = int(float(numeric_info.split(' > ')[1]))

                # expression
                request_expression_str = numeric_info.split(' > ')[0]
                request_expression = request_expression_str.split(' x ')
                failed_request = {}
                request_total = 1
                for num_exp in request_expression:
                    key = num_exp.split(' ')[1]
                    val = int(num_exp.split(' ')[0])
                    failed_request[key] = val
                    request_total *= val
                failed_request['request_total'] = request_total
                failed_request['request_limit'] = request_limit
                
                multi_request = int(request_total/request_limit) + 1
                last_request = request_total%request_limit
                failed_request['multi_request'] = multi_request
                failed_request['last_request'] = last_request


                ee_area_m2 = request['geometry_filter'].area().getInfo()
                # ee_area_km2 = round(ee_area_m2/1000000, 2) 
                day_range = (datetime.datetime.strptime(request['end'], '%Y-%m-%d') - datetime.datetime.strptime(request['start'], '%Y-%m-%d')).days
                
                # NOT RESOLVING BUT GIVING HELP RECOMMENDATIONS
                rec_msg = QMessageBox()
                rec_msg.setIcon(QMessageBox.Information)

                rec_msg.setText("Recommedations")
                rec_msg.setInformativeText("""
                Total Requested datapoints:\t{total}
                Datapoints Limit:\t\t{limit}
                Required Requests:\t\t{multi}

                Reduce Bands to Single Request at a time:\n
                Current Number of Bands:\t{bands}



                Most Effective Solution: Resize GeoFilter Area or Scale Up Resolution (Square factor):\n
                Current GeoFilter Area (m2):\t{area}
                Current Resolution (m):\t{res}
                


                Less Accurate to Predict, Each Day does not have equal number of images\n
                Current Day Range:\t\t{days}
                Current Number of Images:\t{images}


                """.format(total=failed_request['request_total'], limit=failed_request['request_limit'],
                        multi=failed_request['multi_request'], area=round(ee_area_m2, 2), res=request['resolution'],
                        images=failed_request['images'], bands=failed_request['bands'], days=day_range))
                rec_msg.setStandardButtons(QMessageBox.Ok)
                rec_response = rec_msg.exec()

            else:
                QMessageBox.information(self, 'Information', 'Error: {}\n\nCannot Automate Resolution'.format(error_msg), QMessageBox.Ok)
        
        except:
            QMessageBox.information(self, 'Information', 'Error: {}\n\nCannot Automate Resolution'.format(error_msg), QMessageBox.Ok)


    #==============================================================
    # END OF Automation Group
    #==============================================================
    




#==============================================================
# FUNCTIONS not in class, handling the Datasets in Catalog List
#==============================================================


def QGIS_to_GEE_Geometry(points_list):
    """ Take this out of class method, just confusing to debug
    Replacing self.Q2EE_Geometry()
    """
    features = []
    crs = QgsProject.instance().crs().toWkt()

    # multipoly_list = []

    for points in points_list:

        pid = points['geometry_id']

        # need to handle the Multi Polygons here
        poly_type = points[pid]['geometry_type'] 
        if poly_type == 'MultiPolygon':
            num_polygons = int(points[pid]['Parts'])
        else:
            num_polygons = 1
        
        for i in range(1, num_polygons+1):
            ee_shape = []
            # Broken into Parts if MultiPolygon in QGIS
            if poly_type == 'MultiPolygon':
                part = "Part_{}".format(i)
                shape_points = points[pid][part]
            else:
                shape_points = points[pid]['Points']


            # Extract list of lat/lon points for this shape
            num_points = shape_points['points']
            for n in range(0, num_points):
                pt = shape_points[n]
                ee_shape.append([pt['longitude'], pt['latitude']])

            # Add Last set of points to shape
            ee_shape.append([shape_points[0]['longitude'], shape_points[0]['latitude']])

            # Create the Polygon in EE terms from the list of Lat/Lon Points
            ee_poly = ee.Geometry.Polygon([ee_shape])

            if poly_type == 'MultiPolygon':
                # multipoly_list.append([ee_shape])
                multi_id = "{}.{}".format(pid, i)
                ee_feat = ee.Feature(ee_poly, {'id': multi_id})
            else:
                 #, proj=crs)
                ee_feat = ee.Feature(ee_poly, {'id': pid})

            # This needs to be inside the loop for MultiPolygon, for single Poly, works either way
            features.append(ee_feat)


    ee_geometry_filter = ee.FeatureCollection(features)
    return ee_geometry_filter



#=====================================
# Unified method of Extracting Dates from datasets in list
#=====================================

def add_string_days(str_date, days):
    """ Add N days and format based on GEE usage """
    try:
        date = datetime.datetime.strptime(str_date, '%Y-%m-%d')
    except ValueError:
        date = datetime.datetime.strptime(str_date, '%Y%m%dT%H%M%S')
    except ValueError:
        date = datetime.datetime.strptime(str_date, '%Y-%m-%dT%H:%M:%S')
    except ValueError:
        date = datetime.datetime.strptime(str_dat, '%Y-%m-%d %H:%M:%S')

    date = date + datetime.timedelta(days=days)
    altered_date = datetime.datetime.strftime(date, '%Y-%m-%d')

    return altered_date


def convert_date(date):
    """ Extract the date with the known formats """
    try:
        # assert 'dataset_start' in dataset, "No dataset Key"
        # date = dataset['dataset_start']

        # Check 1: None
        if date is None:
            return None

        # Check 2: str(Present)
        elif date == 'Present':
            return date

        # Check 3: ISO
        else:
            # If this format fails, then Except below to different format
            date = datetime.datetime.fromisoformat(date)


    except KeyError as e:
        # QMessageBox.information('', str(e), 'calling get date on wrong dataset or type', QMessageBox.Ok)
        date = None


    except TypeError as e:
        date = None


    # Check 4: Use custom strptime, non-ISO
    except Exception as e:
        date = datetime.datetime.strptime(date, "%Y-%m-%dT%H:%M:%S.%fZ")


    except:
        # new Date time format to check!
        # QMessageBox.information(self, "New DateTime Format", str(date), QMessageBox.Ok)
        date = None

    
    finally:
        return date





#=====================================
# (Temp, but) Unified method of defining Publisher from Metadata
#=====================================

def get_publisher(dataset):
    
    try:
        assert 'dataset_id' in dataset
        publisher = dataset['dataset_id'].split('/')[0]
        return publisher
    except Exception as e:
        return None




#==============================================================
# FUNCTIONS to interact with QGIS Map
#==============================================================


#=====================================
# Init Map
#=====================================

def init_map(external_gui=False):
    # from PyQt5.QtWidgets import QApplication
    # from qgis.core import QgsRasterLayer
    # from qgis.core import QgsVectorLayer
    # from qgis.core import QgsProject
    # from qgis.core import QgsCoordinateReferenceSystem
    # from qgis.utils import iface
 
    # Google Maps: https://mt1.google.com/vt/lyrs=r&x={x}&y={y}&z={z}
    # Google Satellite: http://www.google.cn/maps/vt?lyrs=s@189&gl=cn&x={x}&y={y}&z={z}
    # Google Satellite Hybrid: https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}
    # Google Terrain: https://mt1.google.com/vt/lyrs=t&x={x}&y={y}&z={z}
    # Google Roads: https://mt1.google.com/vt/lyrs=h&x={x}&y={y}&z={z}

    uri = r'crs=EPSG:3857&format&type=xyz&url=https://mt1.google.com/vt/lyrs%3Ds%26x%3D%7Bx%7D%26y%3D%7By%7D%26z%3D%7Bz%7D&zmax=19&zmin=0'
    # uri = r'crs=EPSG:3857&format&type=xyz&url=https://mt1.google.com/vt/lyrs=t&x={x}&y={y}&z={z}')
    # uri = r'crs=EPSG:4326&format&type=xyz&url=https://mt1.google.com/vt/lyrs%3Ds%26x%3D%7Bx%7D%26y%3D%7By%7D%26z%3D%7Bz%7D&zmax=19&zmin=0'

    layer = QgsRasterLayer(uri, 'Google Satellite', 'wms')
    assert layer.isValid()

    # QgsProject.instance().addMapLayer(layer)

    # For External GUI

    # from qgis.gui import QgsMapCanvas
    canvas = QgsMapCanvas()
    canvas.setWindowTitle('You Are Here')
    canvas.setLayers([layer])
    canvas.setExtent(layer.extent())
    canvas.setDestinationCrs(layer.crs())
    # canvas.setDestinationCrs(QgsCoordinateReferenceSystem('EPSG:32617'))

    if external_gui:
        canvas.show()
        # app.exec_()

    else:
        return layer


#=====================================
# CRS Transformations
#=====================================

# def change_map_crs(self):
#     iface.newProject(False)
#     crs = QgsCoordinateReferenceSystem()


#=====================================
# Plot Point
#=====================================

def get_points(Q_Polygon):
    """ extract all points from a polygon"""
    points = {}
    ndx = 0
    # pid = Q_Polygon.id()
    # points["id"] = pid
    for Q_point_pair in Q_Polygon:
        lon = Q_point_pair.x()
        lat = Q_point_pair.y()
        points["points"] = ndx + 1
        points[ndx] = {}
        points[ndx]["latitude"] = lat
        points[ndx]["longitude"] = lon
        ndx += 1

    return points


def plot_point(longitude, latitude):
    poi = QgsPointXY(longitude, latitude)
    # poi = QgsGeometry.fromPointXY(QgsPointXY(lon, lat))
    v_layer = QgsVectorLayer("Point", "You Are Here", "memory")
    pr = v_layer.dataProvider()
    # create a new feature
    seg = QgsFeature()
    # add geometry to feature
    seg.setGeometry(QgsGeometry.fromPointXY(poi))

    # add attributes if necessary
    # update extent of layer
    pr.addFeatures( [ seg ] )
    v_layer.updateExtents()

    # show point
    QgsProject.instance().addMapLayer(v_layer)
    return


def center_point(longitude, latitude):
    """Use Canvas instead of project """
    canvas = iface.mapCanvas()
    poi = QgsPointXY(longitude, latitude)
    iface.zoomToActiveLayer()


def zoom_level():
    """ Read the Current Zoom Level"""
    scale=iface.mapCanvas().scale()
    dpi=iface.mainWindow().physicalDpiX()
    maxScalePerPixel = 156543.04
    inchesPerMeter = 39.37
    zoomlevel = int(round(math.log( ((dpi* inchesPerMeter * maxScalePerPixel) / scale), 2 ), 0))
    return zoomlevel



#=====================================
# Draw Polygon
#=====================================

def plot_polygon(points):
    q_points = [QgsPointXY(p['longitude'], p['latitude']) for p in points]
    # close the loop
    q_points.append(q_points[0])

    # translate into QgsGeometry
    q_poly = QgsGeometry.fromPolylineXY(q_points)
    v_layer = QgsVectorLayer("LineString", "line", "memory")
    pr = v_layer.dataProvider()

    seg = QgsFeature()
    seg.setGeometry(q_poly)
    pr.addFeatures( [ seg ] )
    v_layer.updateExtents()
    QgsProject.instance().addMapLayer(v_layer)

    return

#=====================================
# Import Shapefile
#=====================================

def plot_vector(filename):
    """ Plotting imported shapefiles on QGIS map"""
    vector_fileTypes = ['shp', 'zip', 'geojson']
    almost_vector_fileTypes = ['csv', 'json']

    try:
        assert filename.split('.')[-1] in vector_fileTypes, "Cannot Plot to Vector Layer: {}".format(filename)
        shapename = os.path.basename(filename).split('.')[0]
        v_layer = QgsVectorLayer(filename, shapename, "ogr")
        if not v_layer.isValid():
            raise IOError("Invalid Shapefile {}".format(shapename))
        
        QgsProject.instance().addMapLayer(v_layer)

        # Works better to set Project CRS on the most recent incoming Vector/Raster Layer
        QgsProject.instance().setCrs(v_layer.crs())
        iface.mapCanvas().refreshAllLayers()

    except Exception:
        # if the file is csv or json, try to look for Lat/Lon coordinate columns and form it into geojson
        fileType = filename.split('.')[-1]
        assert fileType in almost_vector_fileTypes, "Cannot Plot Vector Layer: {}".format(filename)
        vector_data = []
        if fileType == 'csv':
            with open(filename, 'r') as fr:
                reader = csv.DictReader(fr, delimiter=',')
                for row in reader:
                    line_data = {}
                    for k,v in row.items():
                        line_data[k] = v

                    vector_data.append(line_data)

        elif fileType == 'json':
            with open(filename, 'r') as fr:
                vector_data = json.load(fr)

        else:
            pass


        try:
            columns = vector_data[0].keys()

            if 'latitude' in columns and 'longitude' in columns:
                lat_col = 'latitude'
                lon_col = 'longitude'
            elif 'lat' in columns and 'lon' in columns:
                lat_col = 'lat'
                lon_col = 'lon'
            elif 'Lat' in columns and 'Lon' in columns:
                lat_col = 'Lat'
                lon_col = 'Lon'
            elif 'Latitude' in columns and 'Longitude' in columns:
                lat_col = 'Latitude'
                lon_col = 'Longitude'
            else:
                assert 1==0, "No Latitude/Longitude pair found in {}".format(filename)
            
            try:
                resolution = float(self.extractResolutionLE.text())
            except:
                resolution = 0

            vector_data = json_to_geojson(vector_data, lat=lat_col, lon=lon_col, resolution=resolution)
        

        except:
            # If it is just json, go ahead and try to plot
            pass



        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setText("Good News!")
        msg.setInformativeText("Coordinates Detected in file\n\nWould you like to save as geojson to plot on map?")
        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        response = msg.exec()
        if response == QMessageBox.Yes:
            # Temporary save as geojson
            temp_filename = filename + '.geojson'
            with open(temp_filename, 'w') as fw:
                geojson.dump(vector_data, fw, indent=4)
            plot_vector(temp_filename)




    except Exception as e:
        error_msg = QMessageBox()
        error_msg.setIcon(QMessageBox.Information)
        error_msg.setText("Error")
        error_msg.setInformativeText(str(e))
        error_msg.setStandardButtons(QMessageBox.Ok)
        error_msg.exec()

    return

#=====================================
# Common Data Types to GeoJson
#=====================================
def get_all_fields(json_list):
    """ need to iterate through entire json list to get all headers"""
    all_fields = []
    for row in json_list:
        col_in_row = list(row.keys())
        for col in col_in_row:
            if col not in all_fields:
                all_fields.append(col)
    return all_fields



def json_to_geojson(json_list, lat='latitude', lon='longitude', resolution=0):
    """ Convert a dataframe into a geojson file, specify which column lat/lon data is in"""
    from .scripts import common 

    if resolution > 0:
        use_geometry = 'Polygon'
    else:
        use_geometry = 'Point'


    geojson = {'type':'FeatureCollection', 'features':[]}
    properties = get_all_fields(json_list)
    for row in json_list:
        feature = {'type':'Feature',
                   'properties':{},
                   'geometry':{'type':use_geometry,
                               'coordinates':[]}}

        if use_geometry == 'Point':
            feature['geometry']['coordinates'] = [float(row[lon]),float(row[lat])]
        elif use_geometry == 'Polygon':
            center_lat = row[lat]
            center_lon = row[lon]
            size = resolution # in meters
            point_list = common.GeneratePolygon(lat=center_lat, lon=center_lon, radius=size, unit='m', sides=4)

            coord_list = []
            for point_pair in point_list:
                this_lon = point_pair['longitude']
                this_lat = point_pair['latitude']
                this_point = [this_lon, this_lat]
                coord_list.append(this_point)

            # first = last
            coord_list.append([point_list[0]['longitude'], point_list[0]['latitude']])

            feature['geometry']['coordinates'] = [coord_list]

        else:
            QMessageBox.information(self, 'Information', 'In Development: {}'.format(use_geometry), QMessageBox.Ok)

        for prop in properties:
            value = ""
            try:
                value = row[prop]

                if value == "":
                    feature['properties'][prop] = None
                else:
                    feature['properties'][prop] = value

            except:
                feature['properties'][prop] = None
                    
        geojson['features'].append(feature)
    return geojson


#=====================================
# Regex check if string color is Hex code
#=====================================
def is_hex(s):
    import re
    return re.fullmatch(r"^[0-9a-fA-F]$", s or "") is not None


def image_time(time_str, time_zone=0, with_time=True):
    """ time stamp for image id"""
    time_stamp = datetime.datetime.strptime(time_str, "%Y%m%dT%H%M%S")
    # date_start = datetime.datetime.strptime(split_text[0], "%Y-%m-%dT%H:%M:%S.%fZ")
    assert isinstance(time_stamp, datetime.datetime), "Not a Datetime object"

    actual_time = time_stamp - datetime.timedelta(hours=time_zone)

    if with_time:
        actual_time_stamp = datetime.datetime.strftime(actual_time, "%Y-%m-%d %H:%M:%S")
    else:
        actual_time_stamp = datetime.datetime.strftime(actual_time, "%Y-%m-%d")

    return actual_time_stamp


def process_IC_band_info(info):
    """For the ImageCollection, The Bands are found within the Features """
    # Attribute of the result getInfo() method, this is a list which contains a dictionary.
    try:
        band_info = info['features'][0]['bands']

    except IndexError as e:
        band_info = []
        error_msg = QMessageBox()
        error_msg.setIcon(QMessageBox.Information)
        error_msg.setText("Response Empty")
        error_msg.setInformativeText('Bands in Image: {}\n\nFeatures in Request: {}\n\nTry Adjusting Date Filters or Location on Map'.format(info['bands'], info['features']))
        error_msg.setStandardButtons(QMessageBox.Ok)
        error_msg.exec()

    finally:

        return band_info



def process_IC_palette(info):
    """ For Image Collection to extract default palette in GetInfo returned data"""
    viz = {}
    for key, val in info["properties"].items():
        if "visualization" in key:
            viz[key] = val

    band_key = '0'        
    viz_min = None
    viz_max = None
    viz_palette = []
    viz_name = None
    viz_band_select = None
    all_visParams = {}
    
    # First eliminate all 'system' keys from info properties
    for key, val in viz.items():
        if 'system' not in key:
            new_key = key.split('_')[-1]

            try:
                val = float(val)
            except:
                pass
            finally:
                all_visParams[new_key] = val

    visParams = {}
    for key, val in all_visParams.items():
        skip = False
        if 'max' == key:
            val = float(val)
        elif 'min' == key:
            val = float(val)
        elif 'palette' == key:
            val = [str(color) for color in val.split(',')]
        elif 'bands' == key:
            val = [val]
        elif 'gamma' == key:
            val = float(val)
        elif 'name' in key:
            skip = True
        else:
            pass

        if not skip:
            visParams[key] = val
            skip = True

    return visParams 

def process_IC_geometry(info):
    """ Find a footprint in Image Collection"""
    # Find Lat/Lon Min/Max
    lat_min = 90
    lat_max = -90
    lon_min = 180
    lon_max = -180
    for feat in info['features']:
        try:
            # geom = feat['properties']['system:footprint']['coordinates']

            lat_min = feat['properties']['LAT_MIN'] if feat['properties']['LAT_MIN'] <= lat_min else lat_min
            lon_min = feat['properties']['LON_MIN'] if feat['properties']['LON_MIN'] <= lon_min else lon_min

            lat_max = feat['properties']['LAT_MAX'] if feat['properties']['LAT_MAX'] >= lat_max else lat_max
            lon_max = feat['properties']['LON_MAX'] if feat['properties']['LON_MAX'] >= lon_max else lon_max

        except:
            pass

    footprint = ee.Geometry.Rectangle([lon_min, lat_min, lon_max, lat_max])
    dataset_footprint = ee.Feature(footprint, {'id': 0})

    return dataset_footprint